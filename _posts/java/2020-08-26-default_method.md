---
date: 2020-08-26 18:40:40
layout: post
title: 자바 8 인 액션
subtitle: 9. 디폴트 메서드
description: 9. 디폴트 메서드
image: https://leejaedoo.github.io/assets/img/java8.png
optimized_image: https://leejaedoo.github.io/assets/img/java8.png
category: java
tags:
  - java
  - 책 정리
paginate: true
comments: true
---
전통적인 자바에서 인터페이스와 관련 메서드는 한 몸처럼 구성된다. 인터페이스를 구현하는 클래스는 인터페이스에서 정의하는 모든 메서드 구현을 제공하거나 아니면 슈퍼클래스의 구현을 상속받아야 한다.<br>
평소에는 큰 문제가 없지만 라이브러리 설계자 입장에서 인터페이스에 새로운 메서드를 추가하는 등 인터페이스를 수정하고 싶을 때는 `이전에 해당 인터페이스를 구현했던 모든 클래스의 구현도 고쳐야 하는 문제`가 발생한다.<br>
하지만, 자바 8에서는 두 가지 방법으로 이 문제를 해결한다.

* 인터페이스 내부에 `정적 메서드(static method)를 사용`하는 방법
* 인터페이스의 기본 구현을 제공할 수 있도록 `디폴트 메서드(default method)`기능을 사용하는 방법

즉, 자바 8에서는 `메서드 구현을 포함하는 인터페이스를 정의할 수 있다.` 결과적으로 기존 인터페이스를 구현하는 클래스는 자동으로 인터페이스에 추가된 새로운 메서드의 디폴트 메서드를 상속받게 된다. 이로써 기존의 코드 구현을 바꾸도록 강요하지 않으면서도 인터페이스를 바꿀 수 있다.

* ex.

```java
default void sort(Comparator<? super E> c) {
    Collectors.sort(this, c);
}

List<Integer> numbers = Arrays.asList(3, 5, 1, 2, 6);
numbers.sort(Comparator.naturalOrder());    //  sort는 List 인터페이스의 디폴트 메서드다.
```

반환형식 void 앞 default라는 키워드를 통해 디폴트 메서드를 선언하고 덕분에 리스트에 직접 sort를 호출할 수 있게 되었다.<br>

디폴트 메서드는 주로 라이브러리 설계자들이 사용한다. 정리하면 디폴트 메서드를 이용하면 자바 API의 호환성을 유지하면서 라이브러리를 변경할 수 있다.

디폴트 메서드가 없던 시절에는 인터페이스에 메서드를 추가하게 되면 해당 인터페이스를 구현하고 있던 기존 클래스에 새로 추가된 메서드를 구현하도록 일일히 고쳐야 했지만, 디폴트 메서드를 이용하면 인터페이스의 기본 구현을 그대로 상속하므로 자유롭게 새로운 메서드를 추가할 수 있게 된다.

> #### 정적 메서드와 인터페이스
> 자바 8에서는 인터페이스에 직접 정적 메서드를 선언할 수 있으므로, 유틸리티 클래스(다양한 정적 메서드를 정의하는 클래스)를 없애고 직접 인터페이스 내부에 정적 메서드를 구현할 수 있다.
 
# 변화하는 API
## API 버전 1
### 사용자 구현
## API 버전 2
### 사용자가 겪는 문제
인터페이스에 새로운 메서드를 추가하면 `바이너리 호환성`은 유지된다. 하지만, 언젠가는 누군가 새로 추가된 메서드를 하위 클래스에서 호출하게 된다면 아래와 같은 런타임 에러가 발생할 것이다.

```text
Exception in thread "main" java.lang.AbstractMethodError:
    com.company.Ellipse.setRelativeSize(II)V
```
두 번째로 사용자가 전체 애플리케이션을 재빌드하게 되면 아래와 같은 컴파일 에러가 발생한다.

```text
com/company/Ellipse.java:6: error: Ellipse is not abstract and does not override abstract method setRelativeSize(int,int) in Resizable
```

> #### 자바 프로그램 변경과 관련된 호환성의 종류
> ##### 바이너리 호환성
> `새로 추가된 메서드를 호출하지만 않으면` 새로운 메서드 구현이 없이도 기존 클래스 파일 구현이 정상 동작한다.
> 인터페이스에 메서드를 추가했을 때는 바이너리 호환성을 유지하지만, 인터페이스를 구현하는 클래스를 재컴파일하면 에러가 발생한다.<br>
> 뭔가를 바꾼 이후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황을 `바이너리 호환성`이라고 한다.(바이너리 실행에는 인증, 준비 해석 등의 과정이 포함된다.)<br>
> ##### 소스 호환성
> 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일할 수 있음을 말한다.<br>
> 예를 들면, 인터페이스에 메서드를 추가하면 소스 호환성이 아니다. 추가한 메서드를 구현하도록 클래스를 고쳐야 하기 때문이다.
> ##### 동작 호환성
> 코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 실행한다는 의미다.<br>
> 예를 들면, 인터페이스에 메서드를 추가하더라도 프로그램에서 추가된 메서드를 호출할 일은 없으므로(혹은 우연히 구현 클래스가 이를 오버라이드했을 수도 있다.) 동작 호환성은 유지된다.

# 디폴트 메서드란 무엇인가?
# 디폴트 메서드 활용 패턴
## 선택형 메서드
## 동작 다중 상속
### 다중 상속 형식
### 기능이 중복되지 않는 최소의 인터페이스
### 인터페이스 조합
## 해석 규칙
### 알아야 할 세 가지 해결 규칙
### 디폴트 메서드를 제공하는 서브인터페이스가 이긴다
## 충돌 그리고 명시적인 문제 해결
### 충돌 해결
## 다이아몬드 문제
# 요약